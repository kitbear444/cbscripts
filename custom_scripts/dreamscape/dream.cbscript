dir "C:\Users\dcwil\AppData\Roaming\PrismLauncher\instances\Latest Snapshot\minecraft\saves\Test"
desc "Dreamscape datapack...reminiscent of lucid blocks"
scale 1

import common
import random

# Custom imports
import player_id
import inv_storage
import items
import dim_change
import dim_events

$PERCENT_CHANCE = 100

$Dimensions = [
    "minecraft:overworld",
    "minecraft:the_nether",
    "minecraft:the_end",
]

$Dreams = [
    "$namespace:dream1",
    "$namespace:dream2",
    "$namespace:sky",
]

$SleeperAngles = {
    "north": 120.0,
    "south": -120.0,
    "east": -120.0,
    "west": 120.0
}

define @Sleeper: @Entity[type=mannequin]
	create {Tags:["sleeper"], pose:"sleeping", immovable:1, hide_description:0, Health:5}
end

# This advancement triggers the '_on_sleep_start' function
advancement player_slept {
    criteria: {
        slept: {
            trigger: "minecraft:slept_in_bed"
        }
    },
    rewards: {
        "function": "$namespace:_on_sleep_start"
    }
}

# This advancement detects when player kills a sleeper and triggers the '_on_sleeper_killed' function
advancement player_killed_sleeper {
    criteria: {
        killed_sleeper: {
            trigger: "minecraft:player_killed_entity",
            conditions: {
                entity: {
                    "type": "minecraft:mannequin",
                    "nbt": "{Tags:[\"sleeper\"]}"
                }
            }
        }
    },
    rewards: {
        "function": "$namespace:_on_sleeper_killed"
    }
}

# Visual advancement granted to player first time they kill their Sleeper
advancement player_killed_sleeper_display {
  "display": {
    "icon": {
      "id": "minecraft:breeze_rod",
      "components": {
        "minecraft:enchantment_glint_override": true
      }
    },
    "title": "Just a Bad Dream",
    "description": "Kill your sleeping self",
    "background": "minecraft:block/cracked_nether_bricks",
    "frame": "challenge",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": true
  },
  "criteria": {
    "impossible": {
      "trigger": "minecraft:impossible"
    }
  }
}

reset
    global_reset()
end

function global_reset()
    /say Dreamscape reset!

    ## Advancements
    # Revoke the temp advancements, just in case
    /advancement revoke @s only $namespace:player_slept
    /advancement revoke @s only $namespace:player_killed_sleeper

    ## Set up scoreboard objectives
    # Resets objectives
    /scoreboard objectives remove hasSlept
    /scoreboard objectives remove sinceDeath
    # FIX: Probably shouldn't reset this one in particular, since the game will lose context of players in dreams or not
    #/scoreboard objectives remove inDream

    # Creates objectives
    /scoreboard objectives add hasSlept minecraft.custom:minecraft.time_since_rest
    /scoreboard objectives add sinceDeath minecraft.custom:minecraft.time_since_death
    /scoreboard objectives add death minecraft.custom:minecraft.deaths
    /scoreboard objectives add inDream dummy
    # Sets every players value to 2 just to bypass the 1 check later
    @a.hasSlept = 2
    # Sets every players value to 2 just to bypass the 1 check later
    @a.sinceDeath = 2

    as @a
        with
            $(ID) = @s.ID
        do
            # Creates a key in the $namespace:inv storage that is a player array that keys on the players' ID, and skips if that player already exists
            /$execute unless data storage $namespace:global players[{ID:$(ID)}] run data modify storage $namespace:global players append value {ID:$(ID)}
            # Adds the UUID for quick usage to the players bucket
            /$execute run data modify storage $namespace:global players[{ID:$(ID)}].UUID set from entity @s UUID
        end
    end
end

# This function is the reward for the advancement
function _on_sleep_start()
    # "Flag" the player so we know they are sleeping
    @s.justSlept = 1
    # Summon sleeping player in position
    summon_sleeper()
    # Revoke the advancement so it can be granted again next time
    /advancement revoke @s only $namespace:player_slept
end

# Handles when a player sleeps
function _handle_sleep()
    @s.ran_number = get_random_number()
    if @s.ran_number <= $PERCENT_CHANCE
        # Store the players inventory
        store()
        # Clear the players inventory for the new dimension
        clear_inventory()
        # Reveal the player's Sleeper
        with
            $(ID) = @s.ID
        do
            /$effect clear @e[tag=sleeper,scores={ID=$(ID)},limit=1]
        end
        # Put player in random dream dimension
        @s.dream_idx = get_random_dimension()
        switch @s.dream_idx
            case $i in $range($len($Dreams))
                $dream = $Dreams[$i]
                # Send player to random dream dimension
                /execute in $dream run spreadplayers ~ ~ 0 5 false @s
            end
        end
        # Identify them as dreaming
        @s.inDream = 1
    end
    @s.justSlept = 0
end

# Handles when a player wakes up
function _handle_wake_up()
    # Kills the Sleeper player
    kill_sleeper()
    # Restore the players inventory
    restore()
    # Identify them as no longer dreaming
    @s.inDream = 0
end

# Handles immediately when a player dies in a dream
function _handle_dream_death()
    # Removes death dropped items if keepInventory = false
    at @s as @s
        clear_inventory()
        /kill @e[type=minecraft:item,distance=..4]
    end
    # Sets players num of deaths back to 0
    @s.death = 0
end

# run every tick
clock tick
    as @a
        if @s.hasSlept == 1 and @s.justSlept == 1
            # Actually teleports the player
            _handle_sleep()
        end

        if @s.death == 1 and @s.inDream == 1
            # Run when the player dies, but before they wake up
            _handle_dream_death()
        end

        if @s.sinceDeath == 1 and @s.inDream == 1
            # Wakes the player up (in this case, due to death)
            _handle_wake_up()
        end
    end
end

# Summon sleeping mannequin player
function summon_sleeper()
    with
        $(ID) = @s.ID
    do
        # Adds the UUID for quick usage to the players bucket
        /$execute run data modify storage $namespace:global players[{ID:$(ID)}].Rotation set from entity @s Rotation
        /$execute run data modify storage $namespace:global players[{ID:$(ID)}].Pos set from entity @s Pos
        # Gets temp id from player
        id = @s.ID
        # Summons the sleeper
        as create @Sleeper
            # Sets the Sleepers name to be the players for skin purposes
            /$data modify entity @s profile.id set from storage $namespace:global players[{ID:$(ID)}].UUID
            # Make the Sleeper invisible initially
            /effect give @s minecraft:invisibility infinite 1 true
            # Set the Sleeper's ID to the same as the player's
            @s.ID = id
        end

        # Moves sleeper into position based on direction of the bed
        bed_south = False
        /say got here 2
		/execute if block ~ ~ ~ #minecraft:beds[facing=south] run scoreboard players set Global bed_south 1
		if bed_south as @Sleeper at @s feet ~ ~ ~-1.5
            $move_sleeper($SleeperAngles['south'], 0, 0)
        end

        bed_north = False
		/execute if block ~ ~ ~ #minecraft:beds[facing=north] run scoreboard players set Global bed_north 1
		if bed_north as @Sleeper at @s feet ~ ~ ~1.5
            $move_sleeper($SleeperAngles['north'], 0, 0)
        end

        bed_east = False
		/execute if block ~ ~ ~ #minecraft:beds[facing=east] run scoreboard players set Global bed_east 1
		if bed_east as @Sleeper at @s feet ~-1.5 ~ ~
            $move_sleeper(0, 0, $SleeperAngles['east'])
        end

        bed_west = False
		/execute if block ~ ~ ~ #minecraft:beds[facing=west] run scoreboard players set Global bed_west 1
		if bed_west as @Sleeper at @s feet ~1.5 ~ ~
            $move_sleeper(0, 0, $SleeperAngles['west'])
        end
    end
end

# Kill the sleeping mannequin player
function kill_sleeper()
    with
        $(ID) = @s.ID
    do
        /say got here
        /$tp @e[tag=sleeper,scores={ID=$(ID)},limit=1] ~ -200 ~
        /$kill @e[tag=sleeper,scores={ID=$(ID)},limit=1]
    end
end

# Moves the sleeping mannequin player to the corresponding location and then rotates them by the inputted value
macro $move_sleeper($xr, $yr, $zr)
    /tp @s ~ ~ ~
    /rotate @s facing ~$xr ~$yr ~$zr
end

# Handles player killing sleeper themself
function _on_sleeper_killed()
    # Clears players inventory before death
    clear_inventory()
    # Temporarily turn on immediately_respawn if its not already on
    immediateRespawn = False
    /execute store result score Global immediateRespawn run gamerule immediate_respawn
    if not immediateRespawn
        /gamerule immediate_respawn true
    end
    # Turns off death messages temporarily to do a custom one
    /gamerule show_death_messages false
    # Kills the player that the sleeper belongs to simulate waking up
    /kill @s
    /tellraw @s ["",{"selector":"@s"},{"text":" was brutally "},{"text":"murdered","strikethrough":true,"color":"dark_red"},{"text":" awoken by "},{"selector":"@s"}]
    # Turns death messages back on
    /gamerule show_death_messages true
    # Turns immediately_respawn back off if necessary
    if not immediateRespawn
        /gamerule immediate_respawn false
    end
    # Revoke the advancement so it can be granted again next time
    /advancement revoke @s only $namespace:player_killed_sleeper
    # If this is the first time the player has done this, grant them the advancement
    /advancement grant @s only $namespace:player_killed_sleeper_display
end

# Just a handy function just for me
function clear_chat()
    for i=1 to 20
        /tellraw @a {text:""}
    end 
end

# Clears the inventory of the running player
function clear_inventory()
    as @s
        /clear
    end
end

# Generates random number between 0 and 100
function get_random_number()
    return randint(0, 100)
end

# Pick random dimension
function get_random_dimension()
    $dreams_len = $len($Dreams)
    return randint(0, $dreams_len)
end

# For testing purposes only
function test()
    /say Testing Dreamscape...
end