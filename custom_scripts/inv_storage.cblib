# Allows for storing and loading inventory
# Note: relies on scoreboard ID system, sets it up if not already set up

$EQUIPMENT_SLOTS = [
    -106,
    100,
    101,
    102,
    103,
]

reset
    # Backs up player data
    backup_data()

    # Erases the this data in the inv namespace
    /data remove storage $namespace:inv players
    /data remove storage $namespace:inv this

    # Creates ID scoreboard
    /scoreboard objectives add ID dummy
    # Counter for setting player IDs
    count = 0

    # Creates dummy Slot
    /scoreboard objectives add Slot dummy
    # Revokes first time advancement so each player is reassigned an ID
    /advancement revoke @a only $namespace:first_join 
end

function init()
    reset()
end

advancement first_join {
	criteria: {
		requirement: {
			trigger: "minecraft:tick"
        }
	},
	rewards: {
		"function": "$namespace:_set_id"
	}
}

# Sets ID for each player
function _set_id()
    @s.ID = count
    count++
end

# Stores the running player's current inventory
function store()
    # Executes store_update with the ID macro
    with
        $(ID) = @s.ID
    do
        # Erases the "this" root for the inv namespace
        /$data remove storage $namespace:inv this[{ID:$(ID)}]
        # Stores data in temporary "this" root key
        /$data modify storage $namespace:inv this[{ID:$(ID)}].Inventory set from entity @s Inventory
        /$data modify storage $namespace:inv this[{ID:$(ID)}].ID set from entity @s ID

        # Formats the equipment to have slots if it's in the new style, making it somewhat backwards compatible(?)
        /$data modify storage $namespace:inv this[{ID:$(ID)}].equipment set from entity @s equipment

        # Formats offhand
        /$execute if data storage $namespace:inv this[{ID:$(ID)}].equipment.offhand run data modify storage $namespace:inv this[{ID:$(ID)}].equipment.offhand merge value {Slot:-106b}
        /$execute if data storage $namespace:inv this[{ID:$(ID)}].equipment.offhand run data modify storage $namespace:inv this[{ID:$(ID)}].Inventory append from storage $namespace:inv this[{ID:$(ID)}].equipment.offhand
        # Formats boot slot
        /$execute if data storage $namespace:inv this[{ID:$(ID)}].equipment.feet run data modify storage $namespace:inv this[{ID:$(ID)}].equipment.feet merge value {Slot:100b}
        /$execute if data storage $namespace:inv this[{ID:$(ID)}].equipment.feet run data modify storage $namespace:inv this[{ID:$(ID)}].Inventory append from storage $namespace:inv this[{ID:$(ID)}].equipment.feet
        # Formats legging slot
        /$execute if data storage $namespace:inv this[{ID:$(ID)}].equipment.legs run data modify storage $namespace:inv this[{ID:$(ID)}].equipment.legs merge value {Slot:101b}
        /$execute if data storage $namespace:inv this[{ID:$(ID)}].equipment.legs run data modify storage $namespace:inv this[{ID:$(ID)}].Inventory append from storage $namespace:inv this[{ID:$(ID)}].equipment.legs
        # Formats chestplate slot
        /$execute if data storage $namespace:inv this[{ID:$(ID)}].equipment.chest run data modify storage $namespace:inv this[{ID:$(ID)}].equipment.chest merge value {Slot:102b}
        /$execute if data storage $namespace:inv this[{ID:$(ID)}].equipment.chest run data modify storage $namespace:inv this[{ID:$(ID)}].Inventory append from storage $namespace:inv this[{ID:$(ID)}].equipment.chest
        # Formats helmet slot
        /$execute if data storage $namespace:inv this[{ID:$(ID)}].equipment.head run data modify storage $namespace:inv this[{ID:$(ID)}].equipment.head merge value {Slot:103b}
        /$execute if data storage $namespace:inv this[{ID:$(ID)}].equipment.head run data modify storage $namespace:inv this[{ID:$(ID)}].Inventory append from storage $namespace:inv this[{ID:$(ID)}].equipment.head
        
        # Deletes temp equipment key
        /$data remove storage $namespace:inv this[{ID:$(ID)}].equipment

        store_update() with macros

        # Clean up this just in case
        /$data remove storage $namespace:inv this[{ID:$(ID)}]
    end
end

# Updates the storage key for the player 
function store_update()
    # Creates a key in the $namespace:inv storage that is a player array that keys on the players' ID, and skips if that player already exists
    /$execute unless data storage $namespace:inv players[{ID:$(ID)}] run data modify storage $namespace:inv players append value {ID:$(ID)}
    # Appends "this" data structure to the players array by ID
    /$data modify storage $namespace:inv players[{ID:$(ID)}] merge from storage $namespace:inv this[{ID:$(ID)}]
end

# Restores the players inventory to them
function restore()
    with
        $(ID) = @s.ID
    do
        # Reading the selected player's data from the entire array of data of all players.
        _restore_read() with macros

        for i=1 to 41
            # This command runs '_restore_item' *only* if the
            # storage list still has an item (Inventory[0]).
            /$execute if data storage $namespace:inv this[{ID:$(ID)}].Inventory[0] run function $namespace:_restore_item with storage $namespace:inv this[{ID:$(ID)}].Inventory[0]
        end

        # Delete stored player's data
        /$data remove storage $namespace:inv players[{ID:$(ID)}]
    end
end


# Grabs the inventory data AND restores it to the player
function _restore_read()
    # Erases the this root for the inv namespace
    /$data remove storage $namespace:inv this[{ID:$(ID)}]
    # Grab the player's saved data from storage
    /$data modify storage $namespace:inv this[{ID:$(ID)}] set from storage $namespace:inv players[{ID:$(ID)}]
end

# Handles formatting the item data, and then adds the item to the player's inventory depending on the type
function _restore_item()
    # Store the Slot NBT in the temp value per player
    /$scoreboard players set @s Slot $(Slot)
    # If a normal item slot, use the _restore_inventory function, otherwise it is equipment
    with
        $(ID) = @s.ID
        $(Slot) = @s.Slot
    do
        # Sets components if it isn't set for an item
        /$execute unless data storage $namespace:inv this[{ID:$(ID)}].Inventory[0].components run data modify storage $namespace:inv this[{ID:$(ID)}].Inventory[0].components set value {}

        switch @s.Slot
            case $i in $range(0, 35)
                # FIX: cbscript will optimize single-line case statements into inline functions as opposed to extra files. However, it always assumes a function name, not command syntax.
                # Fix the compiler later, but for now, the noop function just does nothing
                noop()
                /$function $namespace:_restore_inventory with storage $namespace:inv this[{ID:$(ID)}].Inventory[0]
            end
            case $i in $EQUIPMENT_SLOTS
                # FIX: cbscript will optimize single-line case statements into inline functions as opposed to extra files. However, it always assumes a function name, not command syntax.
                # Fix the compiler later, but for now, the noop function just does nothing
                noop()
                /$function $namespace:_restore_equipment with storage $namespace:inv this[{ID:$(ID)}].Inventory[0]
            end
        end

        # After restore the current item, remove this slot from storage and start restore the next item
        /$data remove storage $namespace:inv this[{ID:$(ID)}].Inventory[0]
    end
end

# Handles restoreing normal items
function _restore_inventory()
    /$loot replace entity @s container.$(Slot) loot {pools:[{rolls:1,entries:[{type:"minecraft:item",name:"$(id)",functions:[{function:"minecraft:set_count",count:$(count)},{function:"minecraft:set_components",components:$(components)}]}]}]}
end

# Handles the special equipment slots
function _restore_equipment()
    /$execute if score @s Slot matches -106 run loot replace entity @s weapon.offhand loot {pools:[{rolls:1,entries:[{type:"minecraft:item",name:"$(id)",functions:[{function:"minecraft:set_count",count:$(count)},{function:"minecraft:set_components",components:$(components)}]}]}]}
    /$execute if score @s Slot matches 100 run loot replace entity @s armor.feet loot {pools:[{rolls:1,entries:[{type:"minecraft:item",name:"$(id)",functions:[{function:"minecraft:set_count",count:$(count)},{function:"minecraft:set_components",components:$(components)}]}]}]}
    /$execute if score @s Slot matches 101 run loot replace entity @s armor.legs loot {pools:[{rolls:1,entries:[{type:"minecraft:item",name:"$(id)",functions:[{function:"minecraft:set_count",count:$(count)},{function:"minecraft:set_components",components:$(components)}]}]}]}
    /$execute if score @s Slot matches 102 run loot replace entity @s armor.chest loot {pools:[{rolls:1,entries:[{type:"minecraft:item",name:"$(id)",functions:[{function:"minecraft:set_count",count:$(count)},{function:"minecraft:set_components",components:$(components)}]}]}]}
    /$execute if score @s Slot matches 103 run loot replace entity @s armor.head loot {pools:[{rolls:1,entries:[{type:"minecraft:item",name:"$(id)",functions:[{function:"minecraft:set_count",count:$(count)},{function:"minecraft:set_components",components:$(components)}]}]}]}
end

# Backups the latest player data on reset...just in case
function backup_data()
    # Grab the player's saved data from storage
    /data modify storage $namespace:inv_bk players set from storage $namespace:inv players
end

# Intentionally blank
function noop()
end